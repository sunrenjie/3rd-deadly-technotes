
Mar 2, 2012

We explored ELF-related topics by hex-dumping a JOS kernel.


$ md5sum obj/kern/kernel
84061538834c69d2c6b61900fd307e30  obj/kern/kernel
$ hexdump -C obj/kern/kernel | less -S

               |<---------------------------------------------------------------- ELF magic
               |      |<--------------------------------------------------------- ELFCLASS32: 32-bit objects
               |      |  |<------------------------------------------------------ ELFDATA2LSB: little endian
               |      |  |  |<--------------------------------------------------- File version, EV_CURRENT
               |      |  |  |  |<------------------------------------------------ ELFOSABI_NONE: ELF extensions used by this file
               |      |  |  |  |   |<-------------------------------------------- EI_ABIVERSION: not specified
          ----------- -- -- -- --  --
00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
            |<------------------------------------------------------------------- e_type: ET_EXEC: Executable file
            |     |<------------------------------------------------------------- e_machine: Intel 80386
            |     |        |<---------------------------------------------------- e_version: 0x1: EV_CURRENT
            |     |        |            |<--------------------------------------- e_entry: virtual address to which the system first transfers control
            |     |        |            |           |<--------------------------- e_phoff: offset of the program header table
          ----- ----- -----------  ----------- -----------
00000010  02 00 03 00 01 00 00 00  0c 00 10 f0 34 00 00 00  |............4...|
               |<---------------------------------------------------------------- e_shoff: offset of the section header table
               |           |<---------------------------------------------------- e_flags
               |           |         |<------------------------------------------ e_ehsize: ELF header's size in bytes
               |           |         |     |<------------------------------------ e_phentsize: program header table entry size in bytes
               |           |         |     |     |<------------------------------ e_phnum: # entries in the program header table
               |           |         |     |     |     |<------------------------ e_shentsize: section header table entry size in bytes
          ----------- -----------  ----- ----- ----- -----
00000020  88 03 01 00 00 00 00 00  34 00 20 00 03 00 28 00  |........4. ...(.|
            |<------------------------------------------------------------------- e_shnum: # entries in the section header table
            |     |<------------------------------------------------------------- e_shstrndx: index for the section name string table in section header table
          ----- -----
00000030  0b 00 08 00 01 00 00 00  00 10 00 00 00 00 10 f0  |................|
00000040  00 00 10 f0 ee 67 00 00  ee 67 00 00 05 00 00 00  |.....g...g......|
00000050  00 10 00 00 01 00 00 00  00 80 00 00 00 70 10 f0  |.............p..|
00000060  00 70 10 f0 20 83 00 00  80 89 00 00 06 00 00 00  |.p.. ...........|
00000070  00 10 00 00 51 e5 74 64  00 00 00 00 00 00 00 00  |....Q.td........|
00000080  00 00 00 00 00 00 00 00  00 00 00 00 07 00 00 00  |................|
00000090  04 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

[20141226] Note in particular that e_phentsize and e_shentsize are fixed in
at least i386 architecture. In boot/main.c for example, we don't even bother to
them. Instead, we use program/section header data structures defined
<inc/elf.h>. In fact, the following if-clause inserted near segment-reading
code in cmain() will never yield true:

	if (ELFHDR->e_phentsize != sizeof(struct Proghdr) ||
	    ELFHDR->e_shentsize != sizeof(struct Secthdr)
	)
		goto bad;

We could deduce that the section name string table header's offset in file is
e_shoff + e_shstrndx * e_shentsize = 0x00010388 + 0x08 * 0x28 = 0x000104C8
Now come to this section:
                                        |<--------------------------------------- sh_name: section name's index into the section header string table
                                        |           |<--------------------------- sh_type: section type; 3(SHT_STRTAB)
                                   ----------- -----------
000104c0  01 00 00 00 01 00 00 00  11 00 00 00 03 00 00 00  |................|
               |<---------------------------------------------------------------- sh_flags
               |           |<---------------------------------------------------- sh_addr: 0 for applicable; since this section will not appear in the memory image of a process
               |           |            |<--------------------------------------- sh_offset of the section: 0x01033c
               |           |            |           |<--------------------------- sh_size: section size in bytes
          ----------- -----------  ----------- -----------
000104d0  00 00 00 00 00 00 00 00  3c 03 01 00 4c 00 00 00  |........<...L...|
000104e0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|

Now we are able to determine the section name section's offset to be sh_offset
= 0x0001033c. It's name is @ sh_name + sh_offset = 0x00000011 + 0x0001033c
= 0x0001034d.

00010320  47 43 43 3a 20 28 44 65  62 69 61 6e 20 34 2e 34  |GCC: (Debian 4.4|
                                               |<-------------------------------- start of the section name string table
                                               --
00010330  2e 35 2d 38 29 20 34 2e  34 2e 35 00 00 2e 73 79  |.5-8) 4.4.5...sy|
                                                  |<----------------------------- '.shstrtab', name for the section name string table itself
                                                  --
00010340  6d 74 61 62 00 2e 73 74  72 74 61 62 00 2e 73 68  |mtab..strtab..sh|
00010350  73 74 72 74 61 62 00 2e  74 65 78 74 00 2e 72 6f  |strtab..text..ro|
00010360  64 61 74 61 00 2e 73 74  61 62 00 2e 73 74 61 62  |data..stab..stab|
00010370  73 74 72 00 2e 64 61 74  61 00 2e 62 73 73 00 2e  |str..data..bss..|
00010380  63 6f 6d 6d 65 6e 74 00  00 00 00 00 00 00 00 00  |comment.........|
00010390  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

Now I wish to manually inspect the symbol table (along with symbol string table).
The section header table starts at e_shoff = 0x00010388(66440), has a total of
e_shnum = 0x0b(11) entries where each entry has e_shentsize = 0x28(40) bytes.
We've decided to use bash script to generate the output.

start=66440
round=11
step=40
for i in `seq 0 $((round-1))`; do
  hexdump -v -s $start -n $step -C obj/kern/kernel
  start=$((start+step))
done | less -S

Here comes the output (with manual annotation):

00010388  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| <- the 1st entry is defined to be null
00010398  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000103a8  00 00 00 00 00 00 00 00                           |........|
000103b0
               |<---------------------------------------------------------------- section 0x01, name string = 0x0001033c + 0x1b = 0x00010357, '.text'
               |           |<---------------------------------------------------- SHT_PROGBITS: section's info determined by the program
          ----------- -----------
000103b0  1b 00 00 00 01 00 00 00  06 00 00 00 00 00 10 f0  |................|
000103c0  00 10 00 00 35 17 00 00  00 00 00 00 00 00 00 00  |....5...........|
000103d0  10 00 00 00 00 00 00 00                           |........|
000103d8
000103d8  21 00 00 00 01 00 00 00  02 00 00 00 40 17 10 f0  |!...........@...| <- 0x0001033c + 0x21 = 0x0001035d, '.rodata'
000103e8  40 27 00 00 54 07 00 00  00 00 00 00 00 00 00 00  |@'..T...........|
000103f8  20 00 00 00 00 00 00 00                           | .......|
00010400
00010400  29 00 00 00 01 00 00 00  02 00 00 00 94 1e 10 f0  |)...............| <- 0x0001033c + 0x29 = 0x00010365, '.stab'
00010410  94 2e 00 00 59 32 00 00  04 00 00 00 00 00 00 00  |....Y2..........|
00010420  04 00 00 00 0c 00 00 00                           |........|
00010428
               |<---------------------------------------------------------------- 0x0001033c + 0x2f = 0x0001036b, '.stabstr'
               |           |<---------------------------------------------------- SHT_STRTAB: string table
          ----------- -----------
00010428  2f 00 00 00 03 00 00 00  02 00 00 00 ed 50 10 f0  |/............P..|
00010438  ed 60 00 00 01 17 00 00  00 00 00 00 00 00 00 00  |.`..............|
00010448  01 00 00 00 00 00 00 00                           |........|
00010450
00010450  38 00 00 00 01 00 00 00  03 00 00 00 00 70 10 f0  |8............p..| <- 0x0001033c + 0x38 = 0x00010374, '.data'
00010460  00 80 00 00 20 83 00 00  00 00 00 00 00 00 00 00  |.... ...........|
00010470  00 10 00 00 00 00 00 00                           |........|
00010478
00010478  3e 00 00 00 08 00 00 00  03 00 00 00 20 f3 10 f0  |>........... ...| <- 0x0001033c + 0x3e = 0x0001037a, '.bss'
00010488  20 03 01 00 60 06 00 00  00 00 00 00 00 00 00 00  | ...`...........|
00010498  20 00 00 00 00 00 00 00                           | .......|
000104a0
000104a0  43 00 00 00 01 00 00 00  30 00 00 00 00 00 00 00  |C.......0.......| <- 0x0001033c + 0x43 = 0x0001037f, '.comment'
000104b0  20 03 01 00 1c 00 00 00  00 00 00 00 00 00 00 00  | ...............|
000104c0  01 00 00 00 01 00 00 00                           |........|
000104c8
               |<---------------------------------------------------------------- 0x0001033c + 0x11 = 0x0001034d, '.shstrtab'
               |           |<---------------------------------------------------- SHT_STRTAB: string table
          ----------- -----------
000104c8  11 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
000104d8  3c 03 01 00 4c 00 00 00  00 00 00 00 00 00 00 00  |<...L...........|
000104e8  01 00 00 00 00 00 00 00                           |........|
000104f0
               |<---------------------------------------------------------------- 0x0001033c + 0x01 = 0x0001033d, '.symtab'
               |           |<---------------------------------------------------- SHT_SYMTAB: symbol table
          ----------- -----------
000104f0  01 00 00 00 02 00 00 00  00 00 00 00 00 00 00 00  |................|
               |<---------------------------------------------------------------- sh_offset: section offset: 0x00010540
               |           |<---------------------------------------------------- sh_size: section size: 0x0610
          ----------- -----------
00010500  40 05 01 00 10 06 00 00  0a 00 00 00 2a 00 00 00  |@...........*...|
               |<---------------------------------------------------------------- sh_addralign: address alignment constraints
               |           |<---------------------------------------------------- sh_entsize: size in bytes for fixed-size entries such as in symbol table
          ----------- -----------
00010510  04 00 00 00 10 00 00 00                           |........|
00010518
               |<---------------------------------------------------------------- 0x0001033c + 0x09 = 0x00010345, '.strtab'
          -----------
00010518  09 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
               |<---------------------------------------------------------------- section offset at 0x00010b50
          -----------
00010528  50 0b 01 00 1b 03 00 00  00 00 00 00 00 00 00 00  |P...............|
00010538  01 00 00 00 00 00 00 00                           |........|
00010540

It shall be noted that:
1. The symbol table section is special in that the section itself is a list of
   fixed-size entries.
2. According to 'System V Application Binary Interface', the section '.strtab'
   holds strings, most commonly the strings that represent the names associated
   with symbol table entries. Apparently, this is what is called 'symbol string
   table'.
3. # entry of the symbol table can be calculated as:
   sh_size / sh_entsize = 0x0610 / 0x10 = 0x61 = 97.
   It's funny to see that the '.strtab' section follows immediately behind
   '.symtab' in file: 0x00010540 + 0x0610 = 0x00010b50.
4. Definition for each entry of the symble table can be found in the definitive
   ref.: 'System V Application Binary Interface'.

Here comes the complete dump of symbol table and string table:
$ hexdump -v -C lab1/obj/kern/kernel -s 0x10540 | less -SN
      1 00010540  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| the 1st entry is defined to be null
      2 00010550  00 00 00 00 00 00 10 f0  00 00 00 00 03 00 01 00  |................|
      3 00010560  00 00 00 00 40 17 10 f0  00 00 00 00 03 00 02 00  |....@...........|
      4 00010570  00 00 00 00 94 1e 10 f0  00 00 00 00 03 00 03 00  |................|
      5 00010580  00 00 00 00 ed 50 10 f0  00 00 00 00 03 00 04 00  |.....P..........|
      6 00010590  00 00 00 00 00 70 10 f0  00 00 00 00 03 00 05 00  |.....p..........|
      7 000105a0  00 00 00 00 20 f3 10 f0  00 00 00 00 03 00 06 00  |.... ...........|
      8 000105b0  00 00 00 00 00 00 00 00  00 00 00 00 03 00 07 00  |................|
      9 000105c0  01 00 00 00 08 00 00 00  00 00 00 00 00 00 f1 ff  |................| CODE_SEL
     10 000105d0  0a 00 00 00 10 00 00 00  00 00 00 00 00 00 f1 ff  |................| DATA_SEL
     11 000105e0  13 00 00 00 18 f0 10 f0  00 00 00 00 00 00 05 00  |................| mygdtdesc
     12 000105f0  1d 00 00 00 2e 00 10 f0  00 00 00 00 00 00 01 00  |................| relocated
     13 00010600  27 00 00 00 3d 00 10 f0  00 00 00 00 00 00 01 00  |'...=...........| spin
     14 00010610  2c 00 00 00 00 f0 10 f0  00 00 00 00 00 00 05 00  |,...............| mygdt
     15 00010620  32 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |2...............| init.c
     16 00010630  39 00 00 00 20 f3 10 f0  04 00 00 00 01 00 06 00  |9... ...........| panicstr
     17 00010640  42 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |B...............| console.c
     18 00010650  4c 00 00 00 44 f3 10 f0  04 00 00 00 01 00 06 00  |L...D...........| 
     19 00010660  5a 00 00 00 48 f3 10 f0  04 00 00 00 01 00 06 00  |Z...H...........|
     20 00010670  64 00 00 00 4c f3 10 f0  04 00 00 00 01 00 06 00  |d...L...........|
     21 00010680  6c 00 00 00 50 f3 10 f0  02 00 00 00 01 00 06 00  |l...P...........|
     22 00010690  74 00 00 00 60 f3 10 f0  08 02 00 00 01 00 06 00  |t...`...........| cons
     23 000106a0  79 00 00 00 f8 03 10 f0  fb 00 00 00 02 00 01 00  |y...............| kbd_proc_data
     24 000106b0  87 00 00 00 40 f3 10 f0  04 00 00 00 01 00 06 00  |....@...........|
     25 000106c0  92 00 00 00 20 18 10 f0  00 01 00 00 01 00 02 00  |.... ...........|
     26 000106d0  9c 00 00 00 20 19 10 f0  00 01 00 00 01 00 02 00  |.... ...........|
     27 000106e0  a7 00 00 00 20 1a 10 f0  10 00 00 00 01 00 02 00  |.... ...........|
     28 000106f0  b0 00 00 00 20 f0 10 f0  00 01 00 00 01 00 05 00  |.... ...........|
     29 00010700  ba 00 00 00 20 f1 10 f0  00 01 00 00 01 00 05 00  |.... ...........|
     30 00010710  c3 00 00 00 20 f2 10 f0  00 01 00 00 01 00 05 00  |.... ...........|
     31 00010720  ca 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |................|
     32 00010730  d4 00 00 00 60 1c 10 f0  24 00 00 00 01 00 02 00  |....`...$.......|
     33 00010740  dd 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |................|
     34 00010750  e6 00 00 00 09 0a 10 f0  13 00 00 00 02 00 01 00  |................|
     35 00010760  ec 00 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |................|
     36 00010770  f7 00 00 00 20 0a 10 f0  f6 00 00 00 02 00 01 00  |.... ...........|
     37 00010780  00 01 00 00 16 0b 10 f0  3d 00 00 00 02 00 01 00  |........=.......|
     38 00010790  08 01 00 00 53 0b 10 f0  1d 00 00 00 02 00 01 00  |....S...........|
     39 000107a0  14 01 00 00 68 1e 10 f0  1c 00 00 00 01 00 02 00  |....h...........|
     40 000107b0  21 01 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |!...............|
     41 000107c0  2c 01 00 00 80 f5 10 f0  00 04 00 00 01 00 06 00  |,...............|
     42 000107d0  30 01 00 00 00 00 00 00  00 00 00 00 04 00 f1 ff  |0...............|
     43 000107e0  39 01 00 00 5a 11 10 f0  20 00 00 00 12 00 01 00  |9...Z... .......| strcpy; va=[0xf010115a, 0xf010117a): sizeof = 0x20; defined at section 0x01('.text')
     44 000107f0  40 01 00 00 3f 03 10 f0  14 00 00 00 12 00 01 00  |@...?...........| kbd_intr
     45 00010800  49 01 00 00 08 07 10 f0  64 00 00 00 12 00 01 00  |I.......d.......| mon_backtrace
     46 00010810  57 01 00 00 80 00 10 f0  5d 00 00 00 12 00 01 00  |W.......].......|
     47 00010820  5e 01 00 00 f5 02 10 f0  05 00 00 00 12 00 01 00  |^...............|
     48 00010830  67 01 00 00 3a 01 10 f0  a1 00 00 00 12 00 01 00  |g...:...........|
     49 00010840  71 01 00 00 04 13 10 f0  5e 00 00 00 12 00 01 00  |q.......^.......|
     50 00010850  79 01 00 00 fa 02 10 f0  45 00 00 00 12 00 01 00  |y.......E.......|
     51 00010860  83 01 00 00 e7 0f 10 f0  28 00 00 00 12 00 01 00  |........(.......|
     52 00010870  8c 01 00 00 70 0b 10 f0  1f 04 00 00 12 00 01 00  |....p...........|
     53 00010880  96 01 00 00 70 03 10 f0  46 00 00 00 12 00 01 00  |....p...F.......|
     54 00010890  a0 01 00 00 ef 09 10 f0  1a 00 00 00 12 00 01 00  |................|
     55 000108a0  a8 01 00 00 db 12 10 f0  29 00 00 00 12 00 01 00  |........).......|
     56 000108b0  af 01 00 00 e0 01 10 f0  20 00 00 00 12 00 01 00  |........ .......|
     57 000108c0  c0 01 00 00 40 10 10 f0  c2 00 00 00 12 00 01 00  |....@...........|
     58 000108d0  c9 01 00 00 00 f0 fb ef  00 00 00 00 10 00 f1 ff  |................|
     59 000108e0  cd 01 00 00 f3 04 10 f0  8a 01 00 00 12 00 01 00  |................|
     60 000108f0  d6 01 00 00 dd 00 10 f0  5d 00 00 00 12 00 01 00  |........].......|
     61 00010900  e5 01 00 00 8f 0f 10 f0  58 00 00 00 12 00 01 00  |........X.......|
     62 00010910  ef 01 00 00 20 f3 10 f0  00 00 00 00 10 00 f1 ff  |.... ...........|
     63 00010920  f5 01 00 00 d1 03 10 f0  27 00 00 00 12 00 01 00  |........'.......|
     64 00010930  ff 01 00 00 00 16 10 f0  35 01 00 00 12 02 01 00  |........5.......|
     65 00010940  09 02 00 00 53 03 10 f0  1d 00 00 00 12 00 01 00  |....S...........|
     66 00010950  15 02 00 00 d0 14 10 f0  28 01 00 00 12 02 01 00  |........(.......|
     67 00010960  1f 02 00 00 c7 03 10 f0  0a 00 00 00 12 00 01 00  |................|
     68 00010970  26 02 00 00 db 13 10 f0  ee 00 00 00 12 00 01 00  |&...............|
     69 00010980  2d 02 00 00 2b 11 10 f0  2f 00 00 00 12 00 01 00  |-...+.../.......|
     70 00010990  35 02 00 00 80 f9 10 f0  00 00 00 00 10 00 f1 ff  |5...............|
     71 000109a0  39 02 00 00 40 00 10 f0  40 00 00 00 12 00 01 00  |9...@...@.......|
     72 000109b0  3f 02 00 00 8b 12 10 f0  2b 00 00 00 12 00 01 00  |?.......+.......|
     73 000109c0  47 02 00 00 7d 06 10 f0  63 00 00 00 12 00 01 00  |G...}...c.......|
     74 000109d0  51 02 00 00 35 17 10 f0  00 00 00 00 10 00 f1 ff  |Q...5...........|
     75 000109e0  57 02 00 00 0c 00 10 f0  00 00 00 00 10 00 01 00  |W...............|
     76 000109f0  5e 02 00 00 00 07 10 f0  08 00 00 00 12 00 01 00  |^...............|
     77 00010a00  67 02 00 00 a8 11 10 f0  41 00 00 00 12 00 01 00  |g.......A.......|
     78 00010a10  6f 02 00 00 18 12 10 f0  46 00 00 00 12 00 01 00  |o.......F.......|
     79 00010a20  77 02 00 00 7a 11 10 f0  2e 00 00 00 12 00 01 00  |w...z...........|
     80 00010a30  7f 02 00 00 62 13 10 f0  53 00 00 00 12 00 01 00  |....b...S.......|
     81 00010a40  86 02 00 00 e0 06 10 f0  13 00 00 00 12 00 01 00  |................|
     82 00010a50  8f 02 00 00 b6 12 10 f0  25 00 00 00 12 00 01 00  |........%.......|
     83 00010a60  96 02 00 00 b6 03 10 f0  11 00 00 00 12 00 01 00  |................|
     84 00010a70  9e 02 00 00 0f 10 10 f0  28 00 00 00 12 00 01 00  |........(.......|
     85 00010a80  a7 02 00 00 e9 11 10 f0  2f 00 00 00 12 00 01 00  |......../.......|
     86 00010a90  ae 02 00 00 00 02 10 f0  5f 00 00 00 12 00 01 00  |........_.......|
     87 00010aa0  ba 02 00 00 5f 02 10 f0  96 00 00 00 12 00 01 00  |...._...........|
     88 00010ab0  c3 02 00 00 00 00 c0 ef  00 00 00 00 10 00 f1 ff  |................|
     89 00010ac0  c7 02 00 00 bc 09 10 f0  33 00 00 00 12 00 01 00  |........3.......|
     90 00010ad0  d0 02 00 00 00 f0 10 f0  00 00 00 00 10 00 05 00  |................|
     91 00010ae0  dd 02 00 00 00 70 10 f0  00 00 00 00 10 00 05 00  |.....p..........|
     92 00010af0  e7 02 00 00 10 11 10 f0  1b 00 00 00 12 00 01 00  |................|
     93 00010b00  ee 02 00 00 5e 12 10 f0  2d 00 00 00 12 00 01 00  |....^...-.......|
     94 00010b10  f5 02 00 00 6c 07 10 f0  b1 00 00 00 12 00 01 00  |....l...........|
     95 00010b20  02 03 00 00 84 08 10 f0  35 01 00 00 12 00 01 00  |........5.......|
     96 00010b30  0a 03 00 00 b5 13 10 f0  26 00 00 00 12 00 01 00  |........&.......|
     97 00010b40  12 03 00 00 1d 08 10 f0  67 00 00 00 12 00 01 00  |........g.......|
     98 00010b50  00 43 4f 44 45 5f 53 45  4c 00 44 41 54 41 5f 53  |.CODE_SEL.DATA_S|
     99 00010b60  45 4c 00 6d 79 67 64 74  64 65 73 63 00 72 65 6c  |EL.mygdtdesc.rel|
    100 00010b70  6f 63 61 74 65 64 00 73  70 69 6e 00 6d 79 67 64  |ocated.spin.mygd|
    101 00010b80  74 00 69 6e 69 74 2e 63  00 70 61 6e 69 63 73 74  |t.init.c.panicst|
    102 00010b90  72 00 63 6f 6e 73 6f 6c  65 2e 63 00 73 65 72 69  |r.console.c.seri|
    103 00010ba0  61 6c 5f 65 78 69 73 74  73 00 61 64 64 72 5f 36  |al_exists.addr_6|
    104 00010bb0  38 34 35 00 63 72 74 5f  62 75 66 00 63 72 74 5f  |845.crt_buf.crt_|
    105 00010bc0  70 6f 73 00 63 6f 6e 73  00 6b 62 64 5f 70 72 6f  |pos.cons.kbd_pro|
    106 00010bd0  63 5f 64 61 74 61 00 73  68 69 66 74 2e 31 33 36  |c_data.shift.136|
    107 00010be0  33 00 73 68 69 66 74 63  6f 64 65 00 74 6f 67 67  |3.shiftcode.togg|
    108 00010bf0  6c 65 63 6f 64 65 00 63  68 61 72 63 6f 64 65 00  |lecode.charcode.|
    109 00010c00  6e 6f 72 6d 61 6c 6d 61  70 00 73 68 69 66 74 6d  |normalmap.shiftm|
    110 00010c10  61 70 00 63 74 6c 6d 61  70 00 6d 6f 6e 69 74 6f  |ap.ctlmap.monito|
    111 00010c20  72 2e 63 00 63 6f 6d 6d  61 6e 64 73 00 70 72 69  |r.c.commands.pri|
    112 00010c30  6e 74 66 2e 63 00 70 75  74 63 68 00 70 72 69 6e  |ntf.c.putch.prin|
    113 00010c40  74 66 6d 74 2e 63 00 70  72 69 6e 74 6e 75 6d 00  |tfmt.c.printnum.|
    114 00010c50  67 65 74 75 69 6e 74 00  73 70 72 69 6e 74 70 75  |getuint.sprintpu|
    115 00010c60  74 63 68 00 65 72 72 6f  72 5f 73 74 72 69 6e 67  |tch.error_string|
    116 00010c70  00 72 65 61 64 6c 69 6e  65 2e 63 00 62 75 66 00  |.readline.c.buf.|
    117 00010c80  73 74 72 69 6e 67 2e 63  00 73 74 72 63 70 79 00  |string.c.strcpy.|
    118 00010c90  6b 62 64 5f 69 6e 74 72  00 6d 6f 6e 5f 62 61 63  |kbd_intr.mon_bac|
    119 00010ca0  6b 74 72 61 63 65 00 5f  70 61 6e 69 63 00 6b 62  |ktrace._panic.kb|
    120 00010cb0  64 5f 69 6e 69 74 00 69  33 38 36 5f 69 6e 69 74  |d_init.i386_init|
    121 00010cc0  00 6d 65 6d 6d 6f 76 65  00 63 6f 6e 73 5f 69 6e  |.memmove.cons_in|
    122 00010cd0  74 72 00 73 6e 70 72 69  6e 74 66 00 76 70 72 69  |tr.snprintf.vpri|
    123 00010ce0  6e 74 66 6d 74 00 63 6f  6e 73 5f 67 65 74 63 00  |ntfmt.cons_getc.|
    124 00010cf0  63 70 72 69 6e 74 66 00  6d 65 6d 63 70 79 00 73  |cprintf.memcpy.s|
    125 00010d00  65 72 69 61 6c 5f 70 72  6f 63 5f 64 61 74 61 00  |erial_proc_data.|
    126 00010d10  72 65 61 64 6c 69 6e 65  00 76 70 64 00 63 67 61  |readline.vpd.cga|
    127 00010d20  5f 70 75 74 63 00 74 65  73 74 5f 62 61 63 6b 74  |_putc.test_backt|
    128 00010d30  72 61 63 65 00 76 73 6e  70 72 69 6e 74 66 00 65  |race.vsnprintf.e|
    129 00010d40  64 61 74 61 00 63 6f 6e  73 5f 69 6e 69 74 00 5f  |data.cons_init._|
    130 00010d50  5f 75 6d 6f 64 64 69 33  00 73 65 72 69 61 6c 5f  |_umoddi3.serial_|
    131 00010d60  69 6e 74 72 00 5f 5f 75  64 69 76 64 69 33 00 69  |intr.__udivdi3.i|
    132 00010d70  73 63 6f 6e 73 00 73 74  72 74 6f 6c 00 73 74 72  |scons.strtol.str|
    133 00010d80  6e 6c 65 6e 00 65 6e 64  00 5f 77 61 72 6e 00 73  |nlen.end._warn.s|
    134 00010d90  74 72 66 69 6e 64 00 63  6f 6e 73 5f 70 75 74 63  |trfind.cons_putc|
    135 00010da0  00 65 74 65 78 74 00 5f  73 74 61 72 74 00 72 65  |.etext._start.re|
    136 00010db0  61 64 5f 65 69 70 00 73  74 72 6c 63 70 79 00 73  |ad_eip.strlcpy.s|
    137 00010dc0  74 72 6e 63 6d 70 00 73  74 72 6e 63 70 79 00 6d  |trncmp.strncpy.m|
    138 00010dd0  65 6d 63 6d 70 00 63 70  75 74 63 68 61 72 00 6d  |emcmp.cputchar.m|
    139 00010de0  65 6d 73 65 74 00 67 65  74 63 68 61 72 00 70 72  |emset.getchar.pr|
    140 00010df0  69 6e 74 66 6d 74 00 73  74 72 63 6d 70 00 73 65  |intfmt.strcmp.se|
    141 00010e00  72 69 61 6c 5f 69 6e 69  74 00 63 67 61 5f 69 6e  |rial_init.cga_in|
    142 00010e10  69 74 00 76 70 74 00 76  63 70 72 69 6e 74 66 00  |it.vpt.vcprintf.|
    143 00010e20  62 6f 6f 74 73 74 61 63  6b 74 6f 70 00 62 6f 6f  |bootstacktop.boo|
    144 00010e30  74 73 74 61 63 6b 00 73  74 72 6c 65 6e 00 73 74  |tstack.strlen.st|
    145 00010e40  72 63 68 72 00 6d 6f 6e  5f 6b 65 72 6e 69 6e 66  |rchr.mon_kerninf|
    146 00010e50  6f 00 6d 6f 6e 69 74 6f  72 00 6d 65 6d 66 69 6e  |o.monitor.memfin|
    147 00010e60  64 00 6d 6f 6e 5f 68 65  6c 70 00                 |d.mon_help.|

It shall be observed that:
1. The last element of each symble table entry is the section for which the
   symble is defined. We could filter the symbol table by section to be '.text'.
2. The symbol table is sort by index to symbol string table. If we were to query
   an instruction's virtual address, it's better we sort our table by base
   virtual address and search by binary-search.

[20141227]
Additional notes:
1. What are .stab and .symtab sections for?

   Yes, both may exist in a ELF file. They contain much info in common. It is
   wierd that lab1 has a challenge to load symbol table to enhance backtrace
   function, while lab2 has an exercise to use stab info for the same purpose
   (stab section is loaded together with text section).

   As far as we could know,
   .stab is for debugging (actually used by debuggers), typically loaded into
   memory (JOS put it in text segment). ELF says nothing about it; we only know
   from output of ELF tool that the section is of type SHT_PROGBITS.
   .symtab is defined as a part of ELF, has a dedicated type SHT_SYMTAB. It is
   not intended to be loaded into memory as part of runtime data.

   Commands:
   display info about .stab section: objdump -G
   display info about .symtab section: readelf -a

